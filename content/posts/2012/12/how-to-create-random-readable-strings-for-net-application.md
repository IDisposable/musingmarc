+++
title = "How to create random readable strings for .Net application"
date = 2012-12-04T16:27:00.000-06:00
updated = 2012-12-04T16:30:25.932-06:00
draft = false
url = '/2012/12/how-to-create-random-readable-strings.html'
tags = [".Net","Crypto","Random","C#","Cryptography"]
+++

### Why would I want to be random?

If you need a random string, I assume you know why you're here. However there are some common uses for random strings I want to list out for the Google juice factor:  

1.  CAPTCHA codes when not using something cool like [reCAPTCHA](http://www.google.com/recaptcha "Stop Spam, Read Books")
2.  Email [verification codes](http://stackoverflow.com/questions/3673574/is-a-random-string-a-good-verification-code "Is a random string a good verification code").
3.  [Nonce](http://en.wikipedia.org/wiki/Cryptographic_nonce "Cryptographic Nonce") values for challenge/response.
4.  [salt](http://en.wikipedia.org/wiki/Salt_(cryptography) "Cryptographic Salt") values to increase entropy on password hashes.
5.  Registration codes.

### How should I generate them in .Net?

There is a simple answer, really. In .Net you can just make a call to [RNGCryptoServiceProvider](http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider(v=vs.100).aspx " MSDN - RNGCryptoServiceProvider")'s [GetNonZeroBytes](http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.getnonzerobytes(v=vs.100).aspx "MSDN - GetNonZeroBytes") method and convert those bytes to characters.  
```
var random = new byte[16];           // whatever size you want
var rng = new RNGCryptoServiceProvider();
rng.GetNonZeroBytes(random);         // Fill with non-zero random bytes

return Convert.ToBase64String(random);  // convert to a string.
```

If you have the [MVC 4](http://nuget.org/packages/Microsoft.AspNet.Mvc) package available, you can use the convenient [Crypto.GenerateSal](http://msdn.microsoft.com/en-us/library/system.web.helpers.crypto.generatesalt(v=vs.111).aspx)t method as a shorthand as it essentially does the above code.  
  
This, of course, limits the returned string to the [Base-64](http://en.wikipedia.org/wiki/Base_64) characters.  

### When should I care about the contents?

In general, you don't care about the contents of the random string. The one generated by logic above is pretty useful as it is a wide set of all-ASCII characters that will not get you in trouble when crossing [code-pages](http://blogs.msdn.com/b/michkap/archive/2005/01/22/358675.aspx).  
  
The biggest downside of this approach is that the string is only using the a 64 character set, so you're excluding a lot of other possible characters, but in most applications that isn't a problem.  In fact, quite the opposite is true. In many cases, we might want to avoid specific characters like the [\+ character](http://en.wikipedia.org/wiki/%2B)  because this might be used in a URL In other cases, you might want to generate a fuller character set (or a specific set  like an all-[emoji](http://en.wikipedia.org/wiki/Emoji) string).  
  
A more common need, though, would be if you need to put something on screen for a user to type (such as a registration code) that should not be easy to mistake characters.  In some fonts, the characters _1, l and I_ or _0, o and 0_ are very easily mistaken. For such cases, you can use a function like the following to generate a reasonably readable string  
```
namespace Silly
{
    using System.Security.Cryptography;

    public static partial class Helpers
    {
        public static string RandomReadableString(int length)
        {
            return "23456789ABCDEFGHJKMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz".RandomString(length);
        }

        public static string RandomString(this string characterSet, int length)
        {
            var rng = new RNGCryptoServiceProvider();
            var random = new byte[length];
            rng.GetNonZeroBytes(random);

            var buffer = new char[length];
            var usableChars = characterSet.ToCharArray();
            var usableLength = usableChars.Length;

            for (int index = 0; index < length; index++)
            {
                buffer[index] = usableChars[random[index] % usableLength];
            }

            return new string(buffer);
        }
    }
}
```

You can call the second function against any string of characters. For example I'm using the _RandomReadableString_ method to generate email confirmation codes that can easily be typed if needed.  

### Boring! Spice it up...

For even more fun, here's some Emoji sequences that can be used for eye charts or stupid ~pet~ code tricks.  

> // Emoji fun  
> // random weather "☀☁☂☃"  
> // random finger pointers "☜☝☞☟"  
> // random zodiac "♈♉♊♋♌♍♎♏♐♑♒♓"  
> // random chess pieces "♔♕♖♗♘♙♚♛♜♝♞♟"  
> // random music notation "♩♪♫♬♭♯"  
> // random trigrams "☰☱☲☳☴☵☶☷"  
> // random planets "♃♄♅♆♇"

---

### Comments

#### I quite like your RandomReadableString() extension…

[Unknown](https://www.blogger.com/profile/14348757128504178693 "noreply@blogger.com") - <time datetime="2012-12-06T07:11:51.184-06:00">Dec 4, 2012</time>

I quite like your RandomReadableString() extension method.  
  
Although is the string guaranteed to be unique?  
  
I would have thought email validation codes, for example, would need to be unique.
---

#### Well, there's "absolutely unique" an…


[IDisposable](https://www.blogger.com/profile/02275315449689041289 "noreply@blogger.com") - <time datetime="2012-12-06T23:32:48.138-06:00">Dec 4, 2012</time>

Well, there's "absolutely unique" and "statistically unique". If you generate a long enough string, it's going to "for all practical purposes" be unique. If you NEED it to be a guarantee, then you put it in a database/store and put a unique index on the value... if you get a collision (not likely), you just loop back and generate another one.  
  
As for EVCs being unique, you can make them be fairly long, linked to the user, and time-sensitive and that'll cure most ills...
---

#### Ooh, pretty pretty bad strin…


[The Director](http://qahatesyou.com "noreply@blogger.com") - <time datetime="2013-01-31T13:31:53.237-06:00">Jan 4, 2013</time>

Ooh, pretty pretty bad strings.
---

#### It is nice, but it couldn't pass a statistical…


[Anonymous](mailto:noreply@blogger.com) - <time datetime="2014-09-03T04:44:56.605-05:00">Sep 3, 2014</time>

It is nice, but it couldn't pass a statistical random test:  
\- you crate a randomized sequence with _RNGCrypto_, which can contain 255 different values  
\- later you use a _MOD_ operator, which projects this value into a **shorter** range (the longer case is not important now)  
\- if the length is not divider of 255, there will be a segment at the begin of the usable character range which will be more frequent than the others  
  
btw. it is a good function to create almost random values :)
---
