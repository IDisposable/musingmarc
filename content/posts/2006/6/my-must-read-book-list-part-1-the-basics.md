+++
title = "My must-read book list (part 1, the basics)"
date = 2006-06-14T13:22:00.000-05:00
updated = 2007-11-19T00:12:03.995-06:00
draft = false
url = '/2006/06/my-must-read-book-list-part-1-basics.html'
tags = ["Web design","books","architecture"]
+++

I have been asked so many times, so I'm putting the list here. I'll updated it from time to time, but this is my list:

Analysis and Design
-------------------

*   Martin Fowler's [Analysis Patterns : Reusable Object Models](http://www.amazon.com/exec/obidos/ASIN/0201895420/marcsmusing0a-20) approaches the recurring patterns that appear in the analysis of systems (not the design/coding as [Design Patterns](http://www.amazon.com/exec/obidos/ASIN/0201633612/marcsmusing0a-20) does). He covers Accountability (organizational), Observations and Measurements (ratios, units, etc.), Corporate Finance, Inventory and Accounting, Planning, Trading, Declarative Contracts, and Trading Packages. He then talks about support patterns for the analysis of the system like, Layering, Application Facades, Type Modelling, and Association Patterns. Martin understands the concepts of modeling better than any person I've every encountered and this book does for analysis what the gang-of-four's Design Patterns does for design.
*   Martin Fowler's [Patterns of Enterprise Application Architecture](http://www.amazon.com/exec/obidos/ASIN/0321127420/marcsmusing0a-20) does for the architecture design phase of systems (especially enterprise/company-wide systems) what [Analysis Patterns](http://www.amazon.com/exec/obidos/ASIN/0201895420/marcsmusing0a-20) does for the analysis phase. This book is a reference volume filled with solutions for common architectural issues that arise when building big systems. The contexts are clearly defined and then the book dives into a problem/solution format. Each pattern clearly solves a recurring issue in systems architecture, with clear explanation of the reasoning behind the pattern.
*   _Gang of Four_'s [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/exec/obidos/ASIN/0201633612/marcsmusing0a-20) is the seminal work on the recurring patterns that appear in the design phase of an application. The patterns revolve around the issues that crop in the "how do we implement that" part of a project. Each one is explained in general terms based on a real-world example.
    

Development Process
-------------------

*   Martin Fowler's [Refactoring: Improving the Design of Existing Code](http://www.amazon.com/exec/obidos/ASIN/0201485672/marcsmusing0a-20) dives into the process behind improving code quality and reuse through the process of refactoring the code. The process of refactoring is integral to modern agile development and this book tells you the patterns to apply, how to apply them in a safe way, and what the benefits and risks of each pattern are. By capturing the process as a set of patterns, Fowler reduces the risks associated with refactoring while improving the chances that you will recognise what refactorings could be applied to improve the code-base.
*   Scott Ambler's [Refactoring Databases : Evolutionary Database Design](http://www.amazon.com/exec/obidos/ASIN/0321293533/marcsmusing0a-20) does for databases what Fowler's [Refactoring](http://www.amazon.com/exec/obidos/ASIN/0201485672/marcsmusing0a-20) did for code. Scott approaches the concepts of evolving a database over time and explains testing, the patterns use when making changes, and the process of improving the quality of both the data and the structure of a database. He clearly explains the processes needed to evolve a database over time as the applications needs change and as the requirements of the database improvements trickle back up to the application code.
*   Kent Beck's [Test Driven Development: By Example](http://www.amazon.com/exec/obidos/ASIN/0321146530/marcsmusing0a-20) clearly explains what the modern movement of TDD is all about. Using clear examples Kent walks you through to process of writing the tests first, making them pass and then refactoring (red, green, refactor). This process leads to code that is provably correct, safe to evolve, and more likely to do what the requirements specify. Kent shows each step, clearly explaining the reasons and methods to apply. This process can also be applied to the database world as Ambler clearly shows in [Refactoring Databases](http://www.amazon.com/exec/obidos/ASIN/0321293533/marcsmusing0a-20).
*   Joel Spolsky's [Joel on Software: And on Diverse and Occasionally Related Matters That Will Prove of Interest to Software Developers, Designers, and Managers, and to Those Who, Whether by Good Fortune or Ill Luck, Work with Them in Some Capacity](http://www.amazon.com/exec/obidos/ASIN/1590593898/marcsmusing0a-20) (winner for longest title this post!) is a collection of Joel's writings over the years on software design, customer focus and company management. This book is for everyone (can't you tell from the title) because he addresses things that affect everyone involved with software development. Each chapter is an essay, and each is a gem filled with ideas written in a very approachable style. Ideal "waiting for the meeting to start" reading.
*   Steve Maguire's [Debugging the Development Process: Practical Strategies for Staying Focused, Hitting Ship Dates, and Building Solid Teams](http://www.amazon.com/exec/obidos/ASIN/B00005R08G/marcsmusing0a-20) talks about how to organize teams to work effectively and how to avoid common snares and impediments to high productivity. It's not a modern "agile" process, but the concepts given are applicable in any environment where there is a team of developers. This book is written for the manager of developers, but even a line-programmer can benefit by learning how to teach their manager to be better.
*   Steve McConnell's [Code Complete](http://www.amazon.com/exec/obidos/ASIN/0735619670/marcsmusing0a-20) dicusses the strategies to follow to get solid, working, well designed and executed systems. Strategies from the simplest of variable naming to the complexity of code performance tuning to the shipping an actual product. This book is written for the line-programmer and even gives good advice on managing your manger. The second edition really builds on the first edition while pulling in more of the modern agile strategies that have evolved.

Perspective
-----------

*   Henry Petroski's [To Engineer Is Human : The Role of Failure in Successful Design](http://www.amazon.com/exec/obidos/ASIN/0679734163/marcsmusing0a-20) discusses actual examples of how engineering designs can (and do) fail. By careful examination of past mistakes you can get a new understanding into how to prevent those kinds of failures in systems you design. The book is a delightful read, and the selected examples are familiar and clearly explained. Simply put, if you know how things have broken in the past, you are more likely to recognize the parallels in your own designs.
*   Charles Petzold's [Code: The Hidden Language of Computer Hardware and Software](http://www.amazon.com/exec/obidos/ASIN/0735611319/marcsmusing0a-20) shows how modern computer programs are really not that different than the signal flags of long ago. Building from the need to communicate over long distances, Petzold shows the evolution of coding systems into telegraphs, ticker tapes all the way to the beginning of the PC era (and frankly he should have stopped there). This book will teach a new perspective to those that have always viewed computers through high-level languages. It is very entertaining and an easy read.

That's about it for this cut, I'll update when I think of others. Stay tuned for posts about [SQL](http://musingmarc.blogspot.com/2006/06/my-must-read-book-list-part-2-sql.html), language-specific and platform-specific books.
